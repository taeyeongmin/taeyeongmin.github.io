<!DOCTYPE html>
<html lang="ko">

<head>
  <title>StudyWith | 민태영</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900" rel="stylesheet">

  <!-- ✅ 상세 페이지 경로: /pages/project-detail/ 이므로 ../../ 로 올라감 -->
  <link rel="stylesheet" href="../../css/open-iconic-bootstrap.min.css">
  <link rel="stylesheet" href="../../css/animate.css">
  <link rel="stylesheet" href="../../css/owl.carousel.min.css">
  <link rel="stylesheet" href="../../css/owl.theme.default.min.css">
  <link rel="stylesheet" href="../../css/magnific-popup.css">
  <link rel="stylesheet" href="../../css/aos.css">
  <link rel="stylesheet" href="../../css/ionicons.min.css">
  <link rel="stylesheet" href="../../css/flaticon.css">
  <link rel="stylesheet" href="../../css/icomoon.css">
  <link rel="stylesheet" href="../../css/style.css">

  <style>
    :root{
      --accent:#F96D00;
      --accent-weak: rgba(249,109,0,.10);
      --ink:#111;
      --muted: rgba(0,0,0,.85);
      --line: rgba(0,0,0,.08);
      --card-shadow: 0 10px 28px rgba(0,0,0,.08);
    }

    /* ✅ navbar가 없는 페이지이므로 상단 여백만 안정적으로 확보 */
    body { padding-top: 48px; }

    /* 헤더 */
    .detail-hero{ padding: 36px 0 18px; }
    .detail-kicker{
      display:inline-flex; align-items:center; gap:8px;
      font-size: 12.5px; color: var(--muted);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.02);
      padding: 6px 10px;
      border-radius: 999px;
    }
    .detail-kicker .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }
    .detail-title{
      margin: 14px 0 10px;
      font-size: clamp(28px, 3vw, 40px);
      font-weight: 800;
      color: var(--ink);
      letter-spacing: -0.5px;
      line-height: 1.2;
    }
    .detail-sub{
      margin: 0;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.7;
      max-width: 84ch;
    }

    /* 상단 요약 카드 */
    .summary-grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 14px;
      margin-top: 18px;
    }
    .summary-card{
      grid-column: span 6;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--card-shadow);
      padding: 16px 16px 14px;
    }
    .summary-card h4{
      margin: 0 0 10px;
      font-size: 14px;
      font-weight: 800;
      color: var(--ink);
    }
    .summary-card ul{
      margin:0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 13.5px;
      line-height: 1.65;
    }
    .summary-card .meta{
      margin: 0;
      color: rgba(0,0,0,.70);
      font-size: 13.5px;
      line-height: 1.65;
    }
    .meta strong{ color: rgba(0,0,0,.92); }

    /* 섹션 */
    .detail-section{ padding: 44px 0; }
    .detail-section.bg-soft{
      background: #fafafa;
      border-top: 1px solid rgba(0,0,0,.03);
      border-bottom: 1px solid rgba(0,0,0,.03);
    }
    .section-title{
      margin: 0 0 14px;
      font-size: 20px;
      font-weight: 800;
      letter-spacing: -0.2px;
      color: var(--ink);
    }
    .section-desc{
      margin: 0 0 18px;
      color: var(--muted);
      line-height: 1.8;
      font-size: 14.5px;
      max-width: 90ch;
    }

    /* 카드 */
    .case{
      border: 1px solid var(--line);
      background:#fff;
      border-radius: 14px;
      box-shadow: var(--card-shadow);
      padding: 18px;
      margin-top: 14px;
    }
    .case-head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 10px;
    }
    .case-title{
      margin:0;
      font-size: 16px;
      font-weight: 800;
      color: var(--ink);
      letter-spacing: -0.2px;
      line-height: 1.35;
    }
    .case-badge{
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 800;
      color: rgba(0,0,0,.72);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.02);
      padding: 6px 10px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .case-grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    .case-item{
      grid-column: span 4;
      border: 1px solid rgba(0,0,0,.06);
      background: rgba(0,0,0,.015);
      border-radius: 12px;
      padding: 12px 12px 10px;
    }
    .case-item h5{
      margin:0 0 6px;
      font-size: 12.5px;
      font-weight: 800;
      color: rgba(0,0,0,.82);
    }
    .case-item p{
      margin:0;
      color: var(--muted);
      font-size: 13.5px;
      line-height: 1.65;
    }

    .metric{
      margin-top: 12px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(249,109,0,.22);
      background: var(--accent-weak);
      color: rgba(0,0,0,.78);
      font-size: 13.5px;
      line-height: 1.65;
    }
    .metric strong{ color: rgba(0,0,0,.92); }
    .metric .accent{ color: var(--accent); font-weight: 900; }

    /* TOC */
    .toc{
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px 16px;
      background: #fff;
      box-shadow: var(--card-shadow);
      position: sticky;
      top: 24px;
      height: 100%;
    }
    .toc h4{
      margin: 0 0 10px;
      font-size: 14px;
      font-weight: 900;
      color: var(--ink);
    }
    .toc a{
      display:block;
      padding: 8px 0;
      color: rgba(0,0,0,.72);
      border-top: 1px dashed rgba(0,0,0,.10);
      text-decoration:none;
      font-size: 13.5px;
    }
    .toc a:first-of-type{ border-top: 0; }
    .toc a:hover{ color: var(--accent); }

    /* CTA / 심화 문서 링크 */
    .cta-grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 14px;
    }
    .cta{
      grid-column: span 6;
      border: 1px solid rgba(0,0,0,.08);
      background: #fff;
      border-radius: 14px;
      box-shadow: var(--card-shadow);
      padding: 14px 14px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      text-decoration:none;
      color: inherit;
      transition: transform .12s ease, border-color .12s ease;
    }
    .cta:hover{
      transform: translateY(-1px);
      border-color: rgba(249,109,0,.35);
    }
    .cta .left h5{
      margin: 0 0 6px;
      font-size: 14px;
      font-weight: 900;
      letter-spacing: -0.2px;
      color: var(--ink);
    }
    .cta .left p{
      margin: 0;
      color: rgba(0,0,0,.72);
      font-size: 13.5px;
      line-height: 1.6;
    }
    .cta .right{
      flex: 0 0 auto;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      font-weight: 900;
      font-size: 13px;
      color: var(--accent);
      white-space: nowrap;
      padding-top: 2px;
    }
    .cta .right .arrow{
      width: 24px; height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(249,109,0,.25);
      background: rgba(249,109,0,.10);
      display:flex;
      align-items:center;
      justify-content:center;
      line-height: 1;
    }

    /* 작은 보조 링크 */
    .tiny-links{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-start;
      margin-top: 10px;
      color: rgba(0,0,0,.72);
      font-size: 13px;
    }
    .tiny-links a{
      color: rgba(0,0,0,.72);
      text-decoration:none;
      border-bottom: 1px dashed rgba(0,0,0,.25);
    }
    .tiny-links a:hover{ color: var(--accent); border-bottom-color: rgba(249,109,0,.55); }

    /* 하단 버튼 */
    .detail-actions{
      margin-top: 28px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:space-between;
      border-top: 1px solid rgba(0,0,0,.06);
      padding-top: 18px;
    }

    @media (max-width: 992px){
      .summary-card{ grid-column: span 12; }
      .case-item{ grid-column: span 12; }
      .cta{ grid-column: span 12; }
      .toc{ position: static; top: auto; }
    }
  </style>
</head>

<body>

  <!-- Hero -->
  <section class="detail-hero">
    <div class="container">
      <span class="detail-kicker"><span class="dot"></span> Side Project · Full Ownership</span>
      <h1 class="detail-title">StudyWith</h1>
      <p class="detail-sub">
        스터디 그룹 <strong>모집 → 가입 → 운영 → 종료</strong> 전 과정을 지원하는 서비스입니다.<br/>
        단순 CRUD가 아니라 운영 과정에서 발생하는 혼선(권한/상태/예외)을 <strong>도메인 규칙</strong>으로 고정했고
        특히 <strong>도메인 이벤트 + Outbox + SSE</strong>를 활용해 <strong>트랜잭션 안정성</strong>과 <strong>실시간성</strong>을 동시에 만족하는
        알림 발송 파이프라인을 설계 구현했습니다.
      </p>

      <div class="row mt-4">
        <div class="col-lg-8">
          <div class="summary-grid">
            <div class="summary-card">
              <h4>핵심 설계 포인트</h4>
              <ul>
                <li><strong>모집 상태/운영 상태를 분리</strong>하고 조건부 전이 규칙으로 운영 흐름을 통제</li>
                <li>방장/매니저/일반 회원 <strong>역할 기반 권한 분리</strong></li>
                <li>쓰기/읽기 패키지 분리(command/query)로 변경 영향 범위 최소화</li>
                <li><strong>도메인 이벤트 → OutboxEvent(BEFORE_COMMIT) → 폴링/재시도 → Notification 저장</strong></li>
                <li><strong>Notification 커밋 후(AFTER_COMMIT) SSE</strong>로 실시간 알림 전송 + <strong>Ping 하트비트</strong></li>
              </ul>
            </div>

            <div class="summary-card">
              <h4>프로젝트 정보</h4>
              <p class="meta mb-1"><strong>언어 및 프레임워크</strong> Java, Spring, React, NextJs</p>
              <p class="meta mb-1"><strong>인증</strong> JWT(Bearer),  OAuth2(Kakao)</p>
              <p class="meta mb-1"><strong>아키텍처</strong> DDD 기반 Layered,  단방향 의존</p>              
              <p class="meta mb-1"><strong>배포</strong> NCP Ubuntu, Nginx Reverse Proxy</p>
              <br>
              <p class="meta mb-0"><strong>문서화</strong> Swagger UI(OpenAPI), ERD</p>              
              <div class="tiny-links">                
                <b><a href="https://github.com/taeyeongmin/study_with_be" target="_blank" rel="noopener">GitHub(BE)</a></b>                
                <b><a href="https://211.188.53.229/swagger-ui/index.html" target="_blank" rel="noopener">Swagger</a></b>
              </div>
            </div>
          </div>
        </div>

        <div class="col-lg-4 mt-4 mt-lg-0">
          <div class="toc">
            <h4>목차</h4>
            <a href="#sec-1">1. 설계 역량을 확장하기 위한 프로젝트 | 유연한 구조를 설계하는 능력</a>
            <a href="#sec-2">2. 서비스 범위 | 사용자,권한,핵심 흐름(모집/운영 분리)</a>
            <a href="#sec-3">3. 핵심 설계 결정</a>
            <a href="#sec-4">4. 알림 파이프라인 요약 | Domain Event · Outbox · SSE</a>            
          </div>
        </div>
        
      </div>
    </div>
  </section>

  <!--  1. 문제 정의 -->
  <section id="sec-1" class="detail-section bg-soft">
    <div class="container">
      <h2 class="section-title">1. 설계 역량을 확장하기 위한 프로젝트 | 유연한 구조를 설계하는 능력</h2>

      <p class="section-desc">
        StudyWith는 단순히 하나의 서비스를 완성하는 것이 목적이 아니라
        <strong>변경에 강한 프로젝트를 설계하는 능력</strong>을 스스로에게 요구하기 위한 사이드 프로젝트였습니다.
      </p>

      <p class="section-desc">
        이전 구축 및 운영 프로젝트를 수행하며
        기능이 추가되고 정책이 변경될수록
        기존 로직과 얽히며 사이드이펙트가 커지는 구조를 경험했습니다.
        작은 정책 수정이 예상보다 넓은 범위에 영향을 미치고
        특정 조건을 고치면 다른 흐름에서 문제가 발생하는 상황을 반복적으로 보게 되었습니다.
      </p>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">그래서 스스로에게 던진 질문</h3>          
        </div>

        <ul class="mb-0" style="padding-left:18px; color: rgba(0,0,0,.70); line-height:1.8;">
          <li>정책이 늘어나도 구조가 무너지지 않게 만들 수 있을까?</li>
          <li>상태와 권한이 복잡해져도 변경 범위를 예측 가능한 구조로 설계할 수 있을까?</li>
          <li>부가 로직(알림 등)이 핵심 로직과 섞이지 않게 분리할 수 있을까?</li>
        </ul>
      </div>
      <br>
      <p class="section-desc">
        StudyWith는 이 질문에 대한 실험이었습니다.
        모집 상태와 운영 상태를 분리하고
        도메인 규칙을 중심에 두며
        알림을 이벤트 기반 구조로 설계한 이유는
        모두 <strong>정책 변경이 발생해도 구조가 흔들리지 않도록 하기 위함</strong>이었습니다.
      </p>

      <div class="metric">
        <strong>핵심 의의</strong><br/>
        이 프로젝트의 가장 큰 성과는 기능 완성이 아니라
        <span class="accent">유연한 프로젝트를 설계하는 능력을 훈련한 것</span>입니다.
        구조를 먼저 고민하고 변경 가능성을 전제로 설계하는 방식으로
        개발 역량을 한 단계 끌어올리고자 했습니다.
      </div>
    </div>
  </section>

  <!-- 2. 서비스 범위 -->
  <section id="sec-2" class="detail-section">
    <div class="container">
      <h2 class="section-title">2. 서비스 범위 | 사용자,권한,핵심 흐름(모집/운영 분리)</h2>
      <p class="section-desc">
        역할과 상태를 기준으로 사용자 흐름을 정의했습니다.
        누가(역할) / 언제(상태) / 무엇을(행위) 할 수 있는지가 고정되면
        기능이 확장되어도 정책과 책임 경계가 흔들리지 않습니다.
      </p>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">주요 사용자와 역할</h3>          
        </div>

        <div class="case-grid">
          <div class="case-item">
            <h5>비회원</h5>
            <p>스터디 그룹 목록/상세 조회</p>
          </div>
          <div class="case-item">
            <h5>회원</h5>
            <p>가입 신청, 참여/탈퇴</p>
          </div>
          <div class="case-item">
            <h5>방장</h5>
            <p>생성/수정/삭제, 매니저 지정, 가입 승인</p>
          </div>
        </div>

        <div class="case-item" style="grid-column: span 12; margin-top: 12px;">
          <h5>매니저</h5>
          <p>
            가입 승인/거부, 공지 관리 등 운영 기능 일부 위임.            
          </p>
        </div>
      </div>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">핵심 사용자 흐름</h3>          
        </div>

        <div class="case-grid">
          <div class="case-item">
            <h5>모집</h5>
            <p>방장이 그룹을 생성하고 모집 정보를 관리</p>
          </div>
          <div class="case-item">
            <h5>가입</h5>
            <p>회원이 신청하고 방장/매니저가 승인/거부</p>
          </div>
          <div class="case-item">
            <h5>운영</h5>
            <p>공지 등 운영 기능을 통해 참여자 관리</p>
          </div>
        </div>

        <p class="mt-3 mb-0" style="color: rgba(0,0,0,.80); line-height:1.8;">
           StudyWith는 상태를 하나의 직선 흐름으로 두지 않고
          <strong>모집 상태(RecruitStatus)</strong>와 <strong>운영 상태(OperateStatus)</strong>를 분리해
          각 상태가 의미하는 정책(허용 행위/전이 조건)을 명확히 했습니다.
        </p>
      </div>
      <div class="case">
  <div class="case-head">
    <h3 class="case-title">상태 전이 정책 요약 (모집 상태 / 운영 상태 분리)</h3>  
  </div>

  <div class="case-grid">
    <div class="case-item">
      <h5>모집 상태(RecruitStatus)</h5>
      <p>
        <strong>RECRUITING → RECRUIT_END</strong> 가능<br/>
        <strong>RECRUIT_END → RECRUITING</strong> 조건부 가능
      </p>
      <p style="margin-top:8px;">
        <strong>재개 조건</strong><br/>
        - 정원이 남아있는 경우<br/>
        - 모집 기간이 지나지 않은 경우
      </p>
    </div>

    <div class="case-item">
      <h5>운영 상태(OperateStatus)</h5>
      <p>
        <strong>ONGOING → CLOSED</strong> 조건부 가능<br/>
        <strong>CLOSED → ONGOING</strong> 불가
      </p>
      <p style="margin-top:8px;">
        <strong>종료 조건</strong><br/>
        - 모집 상태가 <strong>RECRUIT_END</strong> 인 경우에만 가능
      </p>
    </div>

    <div class="case-item">
      <h5>설계 의도</h5>
      <p>
        모집과 운영을 하나의 직선 상태로 관리하면
        재개/종료 조건이 섞여 정책이 흐려질 수 있습니다.<br/><br/>
        StudyWith는 상태를 분리해
        <strong>전이 조건</strong>과 <strong>허용 행위</strong>가 섞이지 않도록 고정했습니다.
      </p>
    </div>
  </div>

  <div class="metric">
    <strong>운영 안정성 포인트</strong><br/>
    운영 종료는 운영 상태의 변화지만 실제로는 모집이 완전히 끝난 뒤에만 허용됩니다.
    즉 <span class="accent">RecruitStatus와 OperateStatus 간의 선행 조건</span>을 명시해
    잘못된 흐름(모집 중 종료, 정책 불일치)을 구조적으로 방지했습니다.
  </div>
</div>
    </div>
  </section>

  <!-- 3. 핵심 설계 결정  -->
  <section id="sec-3" class="detail-section bg-soft">
    <div class="container">
      <h2 class="section-title">3. 핵심 설계 결정</h2>
      <p class="section-desc">
        기능 구현보다 운영 사고를 줄이기 위한 <strong>결정과 근거</strong>를 남겼습니다.        
      </p>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">① DDD 기반 구조에서 도메인 규칙을 중심에 둔 설계</h3>
          <span class="case-badge">DDD · Layered Architecture</span>
        </div>

        <div class="case-grid">
          <div class="case-item">
            <h5>문제</h5>
            <p>
              기능이 늘어날수록 서비스 레이어에 조건 분기가 쌓이면
              도메인 규칙이 분산되고
              정책 변경 시 수정 범위가 예측하기 어려워지는 문제를 지난 프로젝트를 진행하며 겪었습니다.
            </p>
          </div>

          <div class="case-item">
            <h5>결정</h5>
            <p>
              Controller → UseCase → Domain ← Infrastructure
              단방향 의존 구조를 고정하고
              상태 전이·권한·정원 검증 등 핵심 규칙을
              Entity와 Domain Service에 배치했습니다.
            </p>
          </div>

          <div class="case-item">
            <h5>효과</h5>
            <p>
              비즈니스 규칙이 인프라(JPA, DB)나 외부 계층에 의존하지 않게 되었고
              정책 변경 시 수정 범위가 Domain 내부로 수렴되어
              유지보수성과 확장성이 향상되었습니다.
            </p>
          </div>
        </div>

        <div class="metric">
          <strong>핵심 의도</strong><br/>
          StudyWith는 기능 중심이 아니라
          <span class="accent">도메인 규칙이 가장 안쪽에 위치하는 구조</span>를 목표로 설계했습니다.
          JPA 의존성은 Infrastructure로 한정하고
          트랜잭션과 인증/인가는 Application 계층에서 통제하여
          각 계층의 책임을 명확히 분리했습니다.
        </div>
      </div>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">② 역할 기반 권한을 도메인 레벨에서 통제</h3>          
        </div>
        <div class="case-grid">
          <div class="case-item">
            <h5>문제</h5>
            <p>Security 권한만으로는 방장/매니저/일반의 운영 정책을 표현하기 어려움</p>
          </div>
          <div class="case-item">
            <h5>결정</h5>
            <p>도메인 규칙으로 권한 검증(방장만 가능한 행위, 매니저 위임 범위 등)</p>
          </div>
          <div class="case-item">
            <h5>효과</h5>
            <p>권한 경계가 선명해져 운영 주체의 책임 범위가 명확해짐</p>
          </div>
        </div>
      </div>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">③ command/query 분리로 변경 영향 범위 최소화</h3>        
        </div>
        <div class="case-grid">
          <div class="case-item">
            <h5>문제</h5>
            <p>조회/쓰기 요구사항이 섞이면 복잡도와 변경 비용이 증가</p>
          </div>
          <div class="case-item">
            <h5>결정</h5>
            <p>쓰기(usecase)와 읽기(query)를 분리하고 JPA 의존은 Infrastructure로 한정</p>
          </div>
          <div class="case-item">
            <h5>효과</h5>
            <p>요구사항 확장 시 수정 범위 감소 + 도메인 규칙 중심 구조 유지</p>
          </div>
        </div>
      </div>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">④ 도메인 이벤트 + Outbox + SSE로 정합성/실시간성 동시 확보</h3>          
        </div>
        <div class="case-grid">
          <div class="case-item">
            <h5>문제</h5>
            <p>알림을 즉시 발송하면 트랜잭션 롤백/외부 전송 실패 시 정합성이 깨질 수 있음</p>
          </div>
          <div class="case-item">
            <h5>결정</h5>
            <p>도메인 이벤트를 OutboxEvent로 적재(BEFORE_COMMIT) 후 폴링/재시도로 안정 처리</p>
          </div>
          <div class="case-item">
            <h5>효과</h5>
            <p>Notification 저장이 커밋된 뒤(AFTER_COMMIT) SSE 발송 → <strong>저장된 알림만 실시간 전송</strong></p>
          </div>
        </div>

        <div class="metric">
          <strong>핵심 의도</strong><br/>
          알림을 빠르게 보내는 것보다 <span class="accent">실제로 확정된 사실만 누락 없이</span> 전달하는 구조를 목표로 했습니다.
        </div>
      </div>
    </div>
  </section>

  <!-- 4. 알림 파이프라인 요약 -->
  <section id="sec-4" class="detail-section">
    <div class="container">
      <h2 class="section-title">4. 알림 파이프라인 요약 | Domain Event · Outbox · SSE</h2>
      <p class="section-desc">
        StudyWith의 알림은 언제/누구에게/무엇을 보내는지가 도메인 정책에 종속됩니다.
        따라서 알림을 서비스 로직 곳곳에서 직접 호출하지 않고
        <strong>도메인 이벤트로 분리</strong>한 뒤 Outbox를 통해 안정적으로 처리되도록 설계했습니다.
      </p>

      <div class="case">
        <div class="case-head">
          <h3 class="case-title">전체 흐름</h3>        
        </div>

        <div class="case-grid">
          <div class="case-item">
            <h5>1) Domain Event 발행</h5>
            <p>가입 승인/거절/취소, 그룹 상태 변경 등 도메인 사건을 이벤트로 발행</p>
          </div>

          <div class="case-item">
            <h5>2) Outbox 적재 (BEFORE_COMMIT)</h5>
            <p>이벤트를 OutboxEvent(PENDING)로 저장하여 트랜잭션과 원자적으로 묶음</p>
          </div>

          <div class="case-item">
            <h5>3) 폴링/락/재시도 처리</h5>
            <p>스케줄러가 주기적으로 배치를 돌며 이벤트를 PROCESSING→DONE/FAILED로 전이(최대 재시도 포함)</p>
          </div>
        </div>

        <div class="case-grid" style="margin-top: 12px;">
          <div class="case-item">
            <h5>4) Notification 생성</h5>
            <p>알림 대상(수신자)을 전략으로 해석하고 대상별 Notification을 저장</p>
          </div>

          <div class="case-item">
            <h5>5) 커밋 후 SSE 발송 (AFTER_COMMIT)</h5>
            <p>Notification이 DB에 확정된 뒤 SSE로 클라이언트에 실시간 전송</p>
          </div>

          <div class="case-item">
            <h5>6) 연결 안정성</h5>
            <p>SSE Registry로 사용자별 커넥션 관리 + 일정 주기 ping(하트비트)로 연결 유지</p>
          </div>
        </div>

        <p class="mt-3 mb-0" style="color: rgba(0,0,0,.80); line-height:1.8;">
          이 구조를 통해 <strong>발송만 되고 저장이 안 되는 알림</strong>, <strong>저장은 됐는데 실시간 누락되는 알림</strong> 같은 불일치 가능성을 줄였습니다.
        </p>
      </div>

      <div class="detail-actions">
        <a href="../../index.html#projects-section" class="btn btn-primary py-2 px-4">
          프로젝트 목록으로
        </a>
      </div>

    </div>
  </section>
  
  <footer class="ftco-footer ftco-section">
    <div class="container text-center">
      <p class="mb-0">
        Copyright &copy;
        <script>document.write(new Date().getFullYear());</script>
        MinTaeYeong
      </p>
    </div>
  </footer>

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
</body>

</html>
